(define-fun @quantifiers_skolemize_83 () A_list_list$ (choice ((?v1 A_list_list$)) (not (not (= (cons$b nil$b ?v1) (cons$b (filter$ q$ ys$) nil$a))))))
(define-fun @quantifiers_skolemize_87 () A$ (choice ((?v1 A$)) (not (forall ((?v2 A_list$) (?v3 A_list_list$)) (not (= (cons$b (cons$ ?v1 ?v2) ?v3) (cons$b (filter$ q$ ys$) nil$a)))))))
(define-fun @quantifiers_skolemize_88 () A_list$ (choice ((?v2 A_list$)) (not (forall ((?v3 A_list_list$)) (not (= (cons$b (cons$ (choice ((?v1 A$)) (not (forall ((?v2 A_list$) (?v3 A_list_list$)) (not (= (cons$b (cons$ ?v1 ?v2) ?v3) (cons$b (filter$ q$ ys$) nil$a)))))) ?v2) ?v3) (cons$b (filter$ q$ ys$) nil$a)))))))
(define-fun @quantifiers_skolemize_89 () A_list_list$ (choice ((?v3 A_list_list$)) (not (not (= (cons$b (cons$ (choice ((?v1 A$)) (not (forall ((?v2 A_list$) (?v3 A_list_list$)) (not (= (cons$b (cons$ ?v1 ?v2) ?v3) (cons$b (filter$ q$ ys$) nil$a)))))) (choice ((?v2 A_list$)) (not (forall ((?v3 A_list_list$)) (not (= (cons$b (cons$ (choice ((?v1 A$)) (not (forall ((?v2 A_list$) (?v3 A_list_list$)) (not (= (cons$b (cons$ ?v1 ?v2) ?v3) (cons$b (filter$ q$ ys$) nil$a)))))) ?v2) ?v3) (cons$b (filter$ q$ ys$) nil$a))))))) ?v3) (cons$b (filter$ q$ ys$) nil$a))))))
(assume slice_assume_false false)
(anchor :step t569)
(assume t569.a0 (forall ((?v0 A_list_list$)) (or (= nil$a ?v0) (not (forall ((?v1 A_list_list$)) (not (= ?v0 (cons$b nil$b ?v1))))) (not (forall ((?v1 A$) (?v2 A_list$) (?v3 A_list_list$)) (not (= ?v0 (cons$b (cons$ ?v1 ?v2) ?v3))))))))
(anchor :step t569.t3 :args ((?v0 A_list_list$) (:= (?v0 A_list_list$) ?v0)))
(step st569.t3.t0 (cl (= (=> (and (=> (= ?v0 nil$a) false) (and (forall ((?v1 A_list_list$)) (=> (= ?v0 (cons$b nil$b ?v1)) false)) (forall ((?v1 A$) (?v2 A_list$) (?v3 A_list_list$)) (=> (= ?v0 (cons$b (cons$ ?v1 ?v2) ?v3)) false)))) false) (not (and (=> (= ?v0 nil$a) false) (and (forall ((?v1 A_list_list$)) (=> (= ?v0 (cons$b nil$b ?v1)) false)) (forall ((?v1 A$) (?v2 A_list$) (?v3 A_list_list$)) (=> (= ?v0 (cons$b (cons$ ?v1 ?v2) ?v3)) false))))))) :rule rare_rewrite :args ("bool-impl-false1" (and (=> (= ?v0 nil$a) false) (and (forall ((?v1 A_list_list$)) (=> (= ?v0 (cons$b nil$b ?v1)) false)) (forall ((?v1 A$) (?v2 A_list$) (?v3 A_list_list$)) (=> (= ?v0 (cons$b (cons$ ?v1 ?v2) ?v3)) false))))))
(step t569.t3.t11 (cl (= (=> (and (=> (= ?v0 nil$a) false) (and (forall ((?v1 A_list_list$)) (=> (= ?v0 (cons$b nil$b ?v1)) false)) (forall ((?v1 A$) (?v2 A_list$) (?v3 A_list_list$)) (=> (= ?v0 (cons$b (cons$ ?v1 ?v2) ?v3)) false)))) false) (not (and (not (= nil$a ?v0)) (forall ((?v1 A_list_list$)) (not (= ?v0 (cons$b nil$b ?v1)))) (forall ((?v1 A$) (?v2 A_list$) (?v3 A_list_list$)) (not (= ?v0 (cons$b (cons$ ?v1 ?v2) ?v3)))))))) :rule hole)
(step t569.t3 (cl (= (forall ((?v0 A_list_list$)) (=> (and (=> (= ?v0 nil$a) false) (and (forall ((?v1 A_list_list$)) (=> (= ?v0 (cons$b nil$b ?v1)) false)) (forall ((?v1 A$) (?v2 A_list$) (?v3 A_list_list$)) (=> (= ?v0 (cons$b (cons$ ?v1 ?v2) ?v3)) false)))) false)) (forall ((?v0 A_list_list$)) (not (and (not (= nil$a ?v0)) (forall ((?v1 A_list_list$)) (not (= ?v0 (cons$b nil$b ?v1)))) (forall ((?v1 A$) (?v2 A_list$) (?v3 A_list_list$)) (not (= ?v0 (cons$b (cons$ ?v1 ?v2) ?v3))))))))) :rule bind)
(step t569.t7 (cl (or (= nil$a (cons$b (filter$ q$ ys$) nil$a)) (not (forall ((?v1 A_list_list$)) (not (= (cons$b (filter$ q$ ys$) nil$a) (cons$b nil$b ?v1))))) (not (forall ((?v1 A$) (?v2 A_list$) (?v3 A_list_list$)) (not (= (cons$b (filter$ q$ ys$) nil$a) (cons$b (cons$ ?v1 ?v2) ?v3))))))) :rule hole)
(step t569 (cl (not (forall ((?v0 A_list_list$)) (or (= nil$a ?v0) (not (forall ((?v1 A_list_list$)) (not (= ?v0 (cons$b nil$b ?v1))))) (not (forall ((?v1 A$) (?v2 A_list$) (?v3 A_list_list$)) (not (= ?v0 (cons$b (cons$ ?v1 ?v2) ?v3)))))))) (or (= nil$a (cons$b (filter$ q$ ys$) nil$a)) (not (forall ((?v1 A_list_list$)) (not (= (cons$b (filter$ q$ ys$) nil$a) (cons$b nil$b ?v1))))) (not (forall ((?v1 A$) (?v2 A_list$) (?v3 A_list_list$)) (not (= (cons$b (filter$ q$ ys$) nil$a) (cons$b (cons$ ?v1 ?v2) ?v3))))))) :rule subproof :discharge (t569.a0))
(step slice_not_false (cl (not false)) :rule false)
(step t.end (cl) :rule resolution :premises (slice_assume_false slice_not_false))
