
(program has_false ((xs Bool :list))
  :signature (Bool) Bool
  (
  ((has_false (and false xs)) true)
  ((has_false (and true xs)) (has_false (and xs)))
  ((has_false false) true)
  )
)

(declare-rare-rule and_false ((x Bool :list)) 
  :args (x)
  :premises ((= (has_false (and x)) true))
  :conclusion (= (and x) false)
)

(declare-rare-rule or_true_bool ((t1 Bool :list) (t2 Bool) (t3 Bool :list))
  :args (t1 t2 t3)
  :premises ((= (or false t2 false) t2))
  :conclusion (= (or t1 t2 t3) true)
)
(declare-rare-rule arith-mul-one ((@T0 Type) (@T1 Type) (t1 @T0 :list) (s1 @T1 :list))
  :args (t1 s1)
  :conclusion (= (* t1 1 s1) (* t1 s1))
)
(declare-rare-rule arith-mul-zero ((@T0 Type) (@T1 Type) (t1 @T0 :list) (s1 @T1 :list))
  :args (t1 s1)
  :conclusion (= (* t1 0 s1) 0)
)
(declare-rare-rule uf-int2bv-bvult-equiv ((@n0 Int) (@n1 Int) (t1 (BitVec @n0)) (s1 (BitVec @n1)))
  :args (t1 s1)
  :conclusion (= (bvult t1 s1) (bvult s1 t1))
)
(declare-rare-rule ite-else-false ((c1 Bool) (x1 Bool :list))
  :args (c1 x1)
  :conclusion (= (ite c1 x1 false) (and c1 x1))
)
(declare-rare-rule test ((c1 Bool :list))
  :args (c1)
  :conclusion (= (or c1 true) true)
)
(declare-rare-rule eq-symm ((@T0 Type) (@T1 Type) (t1 @T0) (s1 @T1))
  :args (t1 s1)
  :conclusion (= (= t1 s1) (= s1 t1))
)
(declare-rare-rule bool-double-not-elim ((t1 Bool))
  :args (t1)
  :conclusion (= (not (not t1)) t1)
)
(declare-rare-rule explosion ((t1 Bool))
  :args (t1)
  :premises ((= t1 true) (= t1 false))
  :conclusion (= true false)
)
(declare-rare-rule symmetry ((t1 Bool) (t2 Bool))
  :args (t1 t2)
  :premises ((= t1 t2))
  :conclusion (= t2 t1)
)
(declare-rare-rule eq-refl ((@T Type) (t1 @T))
  :args (t1)
  :conclusion (= t1 t1)
)
(declare-rare-rule or-elim-false ((@T Type) (t1 Bool :list) (t2 Bool) (t3 Bool :list))
  :args (t1 t2 t3)
  :premises ((= t2 false))
  :conclusion (= (or t1 t2 t3) (or t1 t3))
)
(declare-rare-rule or-comm ((@T Type) (t1 @T) (t2 @T))
  :args (t1 t2)
  :conclusion (= (or t1 t2) (or t2 t1))
)
(declare-rare-rule absurd_nat ((t1 Int))
  :args (t1)
  :conclusion (= (= (+ t1 1) t1) false)
)
(declare-rare-rule eq_trans ((@T Type) (t1 @T) (t2 @T) (t3 @T))
  :args (t1 t2 t3)
  :premises ((= t1 t2) (= t2 t3))
  :conclusion (= t1 t3)
)

;; now the three rewrite rules:
(declare-rare-rule contains-false
  ((l Bool))
  :args (l)
  :conclusion (= (contains false l) false)
)

(declare-rare-rule contains-head
  ((l Bool) (xs Bool :list))
  :args (l xs)
  :conclusion (= (contains (or l xs) l) true)
)

(declare-rare-rule contains-tail
  ((x Bool) (xs Bool :list) (l Bool))
  :args (x xs l)
  :conclusion (= (contains (or x xs) l)
                 (contains xs l))
)