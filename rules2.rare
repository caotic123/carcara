(declare-const ite (-> (! Type :var A :implicit) Bool A A A))
(declare-const not (-> Bool Bool))
(declare-const or (-> Bool Bool Bool) :right-assoc-nil false)
(declare-const and (-> Bool Bool Bool) :right-assoc-nil true)
(declare-const => (-> Bool Bool Bool) :right-assoc)
(declare-const xor (-> Bool Bool Bool) :left-assoc)
(declare-const = (-> (! Type :var A :implicit) A A Bool) :chainable and)
(declare-const distinct (-> (! Type :var A :implicit) A A Bool) :pairwise and)
(declare-const eo::nil (-> (! Type :var A :implicit) (! Type :var B :implicit) B))

(program has_false ((f (-> Bool Bool Bool)) (xs Bool :list))
  :signature ((-> Bool Bool Bool) Bool) Bool
  (
  ((has_false f (f false xs)) true)
  ((has_false f (f true xs)) (has_false f xs))
  ((has_false f false) true)
  )
)

(declare-rare-rule and_false ((x Bool)) 
  :args (x)
  :premises ((= (has_false and x) true))
  :conclusion (= x false)
)