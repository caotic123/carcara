(declare-rare-rule or_true_bool ((t1 Bool) (t2 Bool :list))
  :args (t1 t2)
  :premises ((= t1 true))
  :conclusion (= (or true t1 t2) true)
)
(declare-rare-rule arith-mul-one ((@T0 Type) (@T1 Type) (t1 @T0 :list) (s1 @T1 :list))
  :args (t1 s1)
  :conclusion (= (* t1 1 s1) (* t1 s1))
)
(declare-rare-rule arith-mul-zero ((@T0 Type) (@T1 Type) (t1 @T0 :list) (s1 @T1 :list))
  :args (t1 s1)
  :conclusion (= (* t1 0 s1) 0)
)
(declare-rare-rule uf-int2bv-bvult-equiv ((@n0 Int) (@n1 Int) (t1 (BitVec @n0)) (s1 (BitVec @n1)))
  :args (t1 s1)
  :conclusion (= (bvult t1 s1) (bvult s1 t1))
)
(declare-rare-rule ite-else-false ((c1 Bool) (x1 Bool :list))
  :args (c1 x1)
  :conclusion (= (ite c1 x1 false) (and c1 x1))
)
(declare-rare-rule test ((c1 Bool :list))
  :args (c1)
  :conclusion (= (or c1 true) true)
)
(declare-rare-rule eq-symm ((@T0 Type) (@T1 Type) (t1 @T0) (s1 @T1))
  :args (t1 s1)
  :conclusion (= (= t1 s1) (= s1 t1))
)
(declare-rare-rule bool-double-not-elim ((t1 Bool))
  :args (t1)
  :conclusion (= (not (not t1)) t1)
)
(declare-rare-rule explosion ((t1 Bool))
  :args (t1)
  :premises ((= t1 true) (= t1 false))
  :conclusion (= true false)
)
(declare-rare-rule symmetry ((t1 Bool) (t2 Bool))
  :args (t1 t2)
  :premises ((= t1 t2))
  :conclusion (= t2 t1)
)
(declare-rare-rule eq-refl ((@T Type) (t1 @T))
  :args (t1)
  :conclusion (= t1 t1)
)
(declare-rare-rule or-elim ((@T Type) (t1 @T) (t2 @T))
  :args (t1 t2)
  :premises ((= t1 false))
  :conclusion (= (or t1 t2) t2)
)
(declare-rare-rule or-comm ((@T Type) (t1 @T) (t2 @T))
  :args (t1 t2)
  :conclusion (= (or t1 t2) (or t2 t1))
)
(declare-rare-rule absurd_nat ((t1 Int))
  :args (t1)
  :conclusion (= (= (+ t1 1) t1) false)
)
(declare-rare-rule eq_trans ((@T Type) (t1 @T) (t2 @T) (t3 @T))
  :args (t1 t2 t3)
  :premises ((= t1 t2) (= t2 t3))
  :conclusion (= t1 t3)
)
