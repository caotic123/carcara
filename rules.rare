(declare-rare-rule or_true_bool ((@T0 Type) (t1 Bool) (t2 @T0 :list))
  :args (t1 t2)
  :premises ((= t1 true))
  :conclusion (= (or true t1 t2) true)
)
(declare-rare-rule arith-mul-one ((@T0 Type) (@T1 Type) (t1 @T0 :list) (s1 @T1 :list))
  :args (t1 s1)
  :conclusion (= (* t1 1 s1) (* t1 s1))
)
(declare-rare-rule arith-mul-zero ((@T0 Type) (@T1 Type) (t1 @T0 :list) (s1 @T1 :list))
  :args (t1 s1)
  :conclusion (= (* t1 0 s1) 0)
)
(declare-rare-rule arith-div-total-real ((@T0 Type) (t1 @T0) (s1 Real))
  :args (t1 s1)
  :premises ((= (= s1 0/1) false))
  :conclusion (= (/ t1 s1) (/_total t1 s1))
)
(declare-rare-rule uf-int2bv-bvult-equiv ((@n0 Int) (@n1 Int) (t1 (BitVec @n0)) (s1 (BitVec @n1)))
  :args (t1 s1)
  :conclusion (= (bvult t1 s1) (< (bv2nat t1) (bv2nat s1)))
)
(declare-rare-rule ite-else-false ((c1 Bool) (x1 Bool))
  :args (c1 x1)
  :conclusion (= (ite c1 x1 false) (and c1 x1))
)
(declare-rare-rule eq-refl ((@T0 Type) (t1 @T0))
  :args (t1)
  :conclusion (= (= t1 t1) true)
)
(declare-rare-rule eq-symm ((@T0 Type) (@T1 Type) (t1 @T0) (s1 @T1))
  :args (t1 s1)
  :conclusion (= (= t1 s1) (= s1 t1))
)
(declare-rare-rule bool-double-not-elim ((t1 Bool))
  :args (t1)
  :conclusion (= (not (not t1)) t1)
)
(declare-rare-rule str-concat-unify-rev ((@T0 Type) (@T1 Type) (@T2 Type) (@T3 Type) (@T4 Type) (s1 (Seq @T0)) (s2 (Seq @T1)) (s3 (Seq @T2) :list) (t1 (Seq @T3)) (t2 (Seq @T4) :list))
  :args (s1 s2 s3 t1 t2)
  :conclusion (= (= (seq.++ s2 s3 s1) (seq.++ t1 t2 s1)) (= ($singleton_elim (seq.++ s2 s3)) ($singleton_elim (seq.++ t1 t2))))
)