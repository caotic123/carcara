(declare-rare-rule arith-mul-one ((@T0 Type) (@T1 Type) (t1 @T0 :list) (s1 @T1 :list))
  :args (t1 s1)
  :conclusion (= (* t1 1 s1) (* t1 s1))
)
(declare-rare-rule arith-mul-zero ((@T0 Type) (@T1 Type) (t1 @T0 :list) (s1 @T1 :list))
  :args (t1 s1)
  :conclusion (= (* t1 0 s1) 0)
)
(declare-rare-rule arith-div-total-real ((@T0 Type) (t1 @T0) (s1 Real))
  :premises ((= (= s1 0/1) false))
  :args (t1 s1)
  :conclusion (= (/ t1 s1) (/_total t1 s1))
)
(declare-rare-rule arith-div-total-int ((@T0 Type) (t1 @T0) (s1 Int))
  :premises ((= (= s1 0) false))
  :args (t1 s1)
  :conclusion (= (/ t1 s1) (/_total t1 s1))
)
(declare-rare-rule arith-div-total-zero-real ((@T0 Type) (t1 @T0))
  :args (t1)
  :conclusion (= (/_total t1 0/1) 0/1)
)
(declare-rare-rule arith-div-total-zero-int ((@T0 Type) (t1 @T0))
  :args (t1)
  :conclusion (= (/_total t1 0) 0/1)
)
(declare-rare-rule arith-int-div-total ((t1 Int) (s1 Int))
  :premises ((= (= s1 0) false))
  :args (t1 s1)
  :conclusion (= (div t1 s1) (div_total t1 s1))
)
(declare-rare-rule arith-int-div-total-one ((t1 Int))
  :args (t1)
  :conclusion (= (div_total t1 1) t1)
)
(declare-rare-rule arith-int-div-total-zero ((t1 Int))
  :args (t1)
  :conclusion (= (div_total t1 0) 0)
)
(declare-rare-rule arith-int-mod-total ((t1 Int) (s1 Int))
  :premises ((= (= s1 0) false))
  :args (t1 s1)
  :conclusion (= (mod t1 s1) (mod_total t1 s1))
)
(declare-rare-rule arith-int-mod-total-one ((t1 Int))
  :args (t1)
  :conclusion (= (mod_total t1 1) 0)
)
(declare-rare-rule arith-int-mod-total-zero ((t1 Int))
  :args (t1)
  :conclusion (= (mod_total t1 0) t1)
)
(declare-rare-rule arith-elim-gt ((@T0 Type) (@T1 Type) (t1 @T0) (s1 @T1))
  :args (t1 s1)
  :conclusion (= (> t1 s1) (not (<= t1 s1)))
)
(declare-rare-rule arith-elim-lt ((@T0 Type) (@T1 Type) (t1 @T0) (s1 @T1))
  :args (t1 s1)
  :conclusion (= (< t1 s1) (not (>= t1 s1)))
)
(declare-rare-rule arith-elim-int-gt ((t1 Int) (s1 Int))
  :args (t1 s1)
  :conclusion (= (> t1 s1) (>= t1 (+ s1 1)))
)
(declare-rare-rule arith-elim-int-lt ((t1 Int) (s1 Int))
  :args (t1 s1)
  :conclusion (= (< t1 s1) (>= s1 (+ t1 1)))
)
(declare-rare-rule arith-elim-leq ((@T0 Type) (@T1 Type) (t1 @T0) (s1 @T1))
  :args (t1 s1)
  :conclusion (= (<= t1 s1) (>= s1 t1))
)
(declare-rare-rule arith-leq-norm ((t1 Int) (s1 Int))
  :args (t1 s1)
  :conclusion (= (<= t1 s1) (not (>= t1 (+ s1 1))))
)
(declare-rare-rule arith-geq-tighten ((t1 Int) (s1 Int))
  :args (t1 s1)
  :conclusion (= (not (>= t1 s1)) (>= s1 (+ t1 1)))
)
(declare-rare-rule arith-geq-norm1-int ((t1 Int) (s1 Int))
  :args (t1 s1)
  :conclusion (= (>= t1 s1) (>= (- t1 s1) 0))
)
(declare-rare-rule arith-geq-norm1-real ((t1 Real) (s1 Real))
  :args (t1 s1)
  :conclusion (= (>= t1 s1) (>= (- t1 s1) 0/1))
)
(declare-rare-rule arith-geq-norm2 ((@T0 Type) (@T1 Type) (t1 @T0) (s1 @T1))
  :args (t1 s1)
  :conclusion (= (>= t1 s1) (<= (- t1) (- s1)))
)
(declare-rare-rule arith-refl-leq ((@T0 Type) (t1 @T0))
  :args (t1)
  :conclusion (= (<= t1 t1) true)
)
(declare-rare-rule arith-refl-lt ((@T0 Type) (t1 @T0))
  :args (t1)
  :conclusion (= (< t1 t1) false)
)
(declare-rare-rule arith-refl-geq ((@T0 Type) (t1 @T0))
  :args (t1)
  :conclusion (= (>= t1 t1) true)
)
(declare-rare-rule arith-refl-gt ((@T0 Type) (t1 @T0))
  :args (t1)
  :conclusion (= (> t1 t1) false)
)
(declare-rare-rule arith-eq-elim-real ((t1 Real) (s1 Real))
  :args (t1 s1)
  :conclusion (= (= t1 s1) (and (>= t1 s1) (<= t1 s1)))
)
(declare-rare-rule arith-eq-elim-int ((t1 Int) (s1 Int))
  :args (t1 s1)
  :conclusion (= (= t1 s1) (and (>= t1 s1) (<= t1 s1)))
)
(declare-rare-rule arith-plus-flatten ((@T0 Type) (@T1 Type) (@T2 Type) (@T3 Type) (xs1 @T0 :list) (w1 @T1) (ys1 @T2 :list) (zs1 @T3 :list))
  :args (xs1 w1 ys1 zs1)
  :conclusion (= (+ xs1 (+ w1 ys1) zs1) (+ xs1 w1 ys1 zs1))
)
(declare-rare-rule arith-mult-flatten ((@T0 Type) (@T1 Type) (@T2 Type) (@T3 Type) (xs1 @T0 :list) (w1 @T1) (ys1 @T2 :list) (zs1 @T3 :list))
  :args (xs1 w1 ys1 zs1)
  :conclusion (= (* xs1 (* w1 ys1) zs1) (* xs1 w1 ys1 zs1))
)
(declare-rare-rule arith-mult-dist ((@T0 Type) (@T1 Type) (@T2 Type) (@T3 Type) (x1 @T0) (y1 @T1) (z1 @T2) (w1 @T3 :list))
  :args (x1 y1 z1 w1)
  :conclusion (= (* x1 (+ y1 z1 w1)) (+ (* x1 y1) (* x1 (+ z1 w1))))
)
(declare-rare-rule arith-abs-elim-int ((x1 Int))
  :args (x1)
  :conclusion (= (abs x1) (ite (< x1 0) (- x1) x1))
)
(declare-rare-rule arith-abs-elim-real ((x1 Real))
  :args (x1)
  :conclusion (= (abs x1) (ite (< x1 0/1) (- x1) x1))
)
(declare-rare-rule arith-to-real-elim ((x1 Real))
  :args (x1)
  :conclusion (= (to_real x1) x1)
)
(declare-rare-rule arith-to-int-elim-to-real ((@T0 Type) (x1 @T0))
  :args (x1)
  :conclusion (= (to_int (to_real x1)) (to_int x1))
)
(declare-rare-rule arith-div-elim-to-real1 ((@T0 Type) (@T1 Type) (x1 @T0) (y1 @T1))
  :args (x1 y1)
  :conclusion (= (/ (to_real x1) y1) (/ x1 y1))
)
(declare-rare-rule arith-div-elim-to-real2 ((@T0 Type) (@T1 Type) (x1 @T0) (y1 @T1))
  :args (x1 y1)
  :conclusion (= (/ x1 (to_real y1)) (/ x1 y1))
)
(declare-rare-rule arith-sine-zero ()
  :args ()
  :conclusion (= (sin 0/1) 0/1)
)
(declare-rare-rule arith-sine-pi2 ()
  :args ()
  :conclusion (= (sin (* 1/2 real.pi)) 1/1)
)
(declare-rare-rule arith-cosine-elim ((x1 Real))
  :args (x1)
  :conclusion (= (cos x1) (sin (- (* 1/2 real.pi) x1)))
)
(declare-rare-rule arith-tangent-elim ((x1 Real))
  :args (x1)
  :conclusion (= (tan x1) (/ (sin x1) (cos x1)))
)
(declare-rare-rule arith-secent-elim ((x1 Real))
  :args (x1)
  :conclusion (= (sec x1) (/ 1/1 (sin x1)))
)
(declare-rare-rule arith-cosecent-elim ((x1 Real))
  :args (x1)
  :conclusion (= (csc x1) (/ 1/1 (cos x1)))
)
(declare-rare-rule arith-cotangent-elim ((x1 Real))
  :args (x1)
  :conclusion (= (cot x1) (/ (cos x1) (sin x1)))
)
(declare-rare-rule arith-pi-not-int ()
  :args ()
  :conclusion (= (is_int real.pi) false)
)
(declare-rare-rule arith-abs-eq ((@T0 Type) (@T1 Type) (x1 @T0) (y1 @T1))
  :args (x1 y1)
  :conclusion (= (= (abs x1) (abs y1)) (or (= x1 y1) (= x1 (- y1))))
)
(declare-rare-rule arith-abs-int-gt ((x1 Int) (y1 Int))
  :args (x1 y1)
  :conclusion (= (> (abs x1) (abs y1)) (ite (>= x1 0) (ite (>= y1 0) (> x1 y1) (> x1 (- y1))) (ite (>= y1 0) (> (- x1) y1) (> (- x1) (- y1)))))
)
(declare-rare-rule arith-abs-real-gt ((x1 Real) (y1 Real))
  :args (x1 y1)
  :conclusion (= (> (abs x1) (abs y1)) (ite (>= x1 0/1) (ite (>= y1 0/1) (> x1 y1) (> x1 (- y1))) (ite (>= y1 0/1) (> (- x1) y1) (> (- x1) (- y1)))))
)
(declare-rare-rule arith-geq-ite-lift ((@T0 Type) (@T1 Type) (@T2 Type) (C1 Bool) (t1 @T0) (s1 @T1) (r1 @T2))
  :args (C1 t1 s1 r1)
  :conclusion (= (>= (ite C1 t1 s1) r1) (ite C1 (>= t1 r1) (>= s1 r1)))
)
(declare-rare-rule arith-gt-ite-lift ((@T0 Type) (@T1 Type) (@T2 Type) (C1 Bool) (t1 @T0) (s1 @T1) (r1 @T2))
  :args (C1 t1 s1 r1)
  :conclusion (= (> (ite C1 t1 s1) r1) (ite C1 (> t1 r1) (> s1 r1)))
)
(declare-rare-rule arith-leq-ite-lift ((@T0 Type) (@T1 Type) (@T2 Type) (C1 Bool) (t1 @T0) (s1 @T1) (r1 @T2))
  :args (C1 t1 s1 r1)
  :conclusion (= (<= (ite C1 t1 s1) r1) (ite C1 (<= t1 r1) (<= s1 r1)))
)
(declare-rare-rule arith-lt-ite-lift ((@T0 Type) (@T1 Type) (@T2 Type) (C1 Bool) (t1 @T0) (s1 @T1) (r1 @T2))
  :args (C1 t1 s1 r1)
  :conclusion (= (< (ite C1 t1 s1) r1) (ite C1 (< t1 r1) (< s1 r1)))
)
(declare-rare-rule arith-min-lt1 ((@T0 Type) (@T1 Type) (t1 @T0) (s1 @T1))
  :args (t1 s1)
  :conclusion (= (<= (ite (< t1 s1) t1 s1) t1) true)
)
(declare-rare-rule arith-min-lt2 ((@T0 Type) (@T1 Type) (t1 @T0) (s1 @T1))
  :args (t1 s1)
  :conclusion (= (<= (ite (< t1 s1) t1 s1) s1) true)
)
(declare-rare-rule arith-max-geq1 ((@T0 Type) (@T1 Type) (t1 @T0) (s1 @T1))
  :args (t1 s1)
  :conclusion (= (>= (ite (>= t1 s1) t1 s1) t1) true)
)
(declare-rare-rule arith-max-geq2 ((@T0 Type) (@T1 Type) (t1 @T0) (s1 @T1))
  :args (t1 s1)
  :conclusion (= (>= (ite (>= t1 s1) t1 s1) s1) true)
)
(declare-rare-rule array-read-over-write ((@T0 Type) (@T1 Type) (@T2 Type) (@T3 Type) (t1 (Array @T0 @T1)) (i1 @T2) (e1 @T3))
  :args (t1 i1 e1)
  :conclusion (= (select (store t1 i1 e1) i1) e1)
)
(declare-rare-rule array-read-over-write2 ((@T0 Type) (@T1 Type) (@T2 Type) (@T3 Type) (@T4 Type) (t1 (Array @T0 @T1)) (i1 @T2) (j1 @T3) (e1 @T4))
  :premises ((= (= i1 j1) false))
  :args (t1 i1 j1 e1)
  :conclusion (= (select (store t1 i1 e1) j1) (select t1 j1))
)
(declare-rare-rule array-store-overwrite ((@T0 Type) (@T1 Type) (@T2 Type) (@T3 Type) (@T4 Type) (t1 (Array @T0 @T1)) (i1 @T2) (e1 @T3) (f1 @T4))
  :args (t1 i1 e1 f1)
  :conclusion (= (store (store t1 i1 e1) i1 f1) (store t1 i1 f1))
)
(declare-rare-rule array-store-self ((@T0 Type) (@T1 Type) (@T2 Type) (t1 (Array @T0 @T1)) (i1 @T2))
  :args (t1 i1)
  :conclusion (= (store t1 i1 (select t1 i1)) t1)
)
(declare-rare-rule array-read-over-write-split ((@T0 Type) (@T1 Type) (@T2 Type) (@T3 Type) (@T4 Type) (t1 (Array @T0 @T1)) (i1 @T2) (e1 @T3) (j1 @T4))
  :args (t1 i1 e1 j1)
  :conclusion (= (select (store t1 j1 e1) i1) (ite (= i1 j1) e1 (select t1 i1)))
)
(declare-rare-rule array-store-swap ((@T0 Type) (@T1 Type) (@T2 Type) (@T3 Type) (@T4 Type) (@T5 Type) (t1 (Array @T0 @T1)) (i1 @T2) (j1 @T3) (e1 @T4) (f1 @T5))
  :premises ((= (= i1 j1) false))
  :args (t1 i1 j1 e1 f1)
  :conclusion (= (store (store t1 i1 e1) j1 f1) (store (store t1 j1 f1) i1 e1))
)
(declare-rare-rule bool-double-not-elim ((t1 Bool))
  :args (t1)
  :conclusion (= (not (not t1)) t1)
)
(declare-rare-rule bool-not-true ((t1 Bool))
  :premises ((= t1 false))
  :args (t1)
  :conclusion (= (not t1) true)
)
(declare-rare-rule bool-not-false ((t1 Bool))
  :premises ((= t1 true))
  :args (t1)
  :conclusion (= (not t1) false)
)
(declare-rare-rule bool-eq-true ((t1 Bool))
  :args (t1)
  :conclusion (= (= t1 true) t1)
)
(declare-rare-rule bool-eq-false ((t1 Bool))
  :args (t1)
  :conclusion (= (= t1 false) (not t1))
)
(declare-rare-rule bool-eq-nrefl ((x1 Bool))
  :args (x1)
  :conclusion (= (= x1 (not x1)) false)
)
(declare-rare-rule bool-impl-false1 ((t1 Bool))
  :args (t1)
  :conclusion (= (=> t1 false) (not t1))
)
(declare-rare-rule bool-impl-false2 ((t1 Bool))
  :args (t1)
  :conclusion (= (=> false t1) true)
)
(declare-rare-rule bool-impl-true1 ((t1 Bool))
  :args (t1)
  :conclusion (= (=> t1 true) true)
)
(declare-rare-rule bool-impl-true2 ((t1 Bool))
  :args (t1)
  :conclusion (= (=> true t1) t1)
)
(declare-rare-rule bool-impl-elim ((t1 Bool) (s1 Bool))
  :args (t1 s1)
  :conclusion (= (=> t1 s1) (or (not t1) s1))
)
(declare-rare-rule bool-or-true ((xs1 Bool :list) (ys1 Bool :list))
  :args (xs1 ys1)
  :conclusion (= (or xs1 true ys1) true)
)
(declare-rare-rule bool-or-flatten ((xs1 Bool :list) (b1 Bool) (ys1 Bool :list) (zs1 Bool :list))
  :args (xs1 b1 ys1 zs1)
  :conclusion (= (or xs1 (or b1 ys1) zs1) (or xs1 b1 ys1 zs1))
)
(declare-rare-rule bool-and-false ((xs1 Bool :list) (ys1 Bool :list))
  :args (xs1 ys1)
  :conclusion (= (and xs1 false ys1) false)
)
(declare-rare-rule bool-and-flatten ((xs1 Bool :list) (b1 Bool) (ys1 Bool :list) (zs1 Bool :list))
  :args (xs1 b1 ys1 zs1)
  :conclusion (= (and xs1 (and b1 ys1) zs1) (and xs1 b1 ys1 zs1))
)
(declare-rare-rule bool-and-conf ((xs1 Bool :list) (w1 Bool) (ys1 Bool :list) (zs1 Bool :list))
  :args (xs1 w1 ys1 zs1)
  :conclusion (= (and xs1 w1 ys1 (not w1) zs1) false)
)
(declare-rare-rule bool-and-conf2 ((xs1 Bool :list) (w1 Bool) (ys1 Bool :list) (zs1 Bool :list))
  :args (xs1 w1 ys1 zs1)
  :conclusion (= (and xs1 (not w1) ys1 w1 zs1) false)
)
(declare-rare-rule bool-or-taut ((xs1 Bool :list) (w1 Bool) (ys1 Bool :list) (zs1 Bool :list))
  :args (xs1 w1 ys1 zs1)
  :conclusion (= (or xs1 w1 ys1 (not w1) zs1) true)
)
(declare-rare-rule bool-or-taut2 ((xs1 Bool :list) (w1 Bool) (ys1 Bool :list) (zs1 Bool :list))
  :args (xs1 w1 ys1 zs1)
  :conclusion (= (or xs1 (not w1) ys1 w1 zs1) true)
)
(declare-rare-rule bool-or-de-morgan ((x1 Bool) (y1 Bool) (zs1 Bool :list))
  :args (x1 y1 zs1)
  :conclusion (= (not (or x1 y1 zs1)) (and (not x1) (not (or y1 zs1))))
)
(declare-rare-rule bool-implies-de-morgan ((x1 Bool) (y1 Bool))
  :args (x1 y1)
  :conclusion (= (not (=> x1 y1)) (and x1 (not y1)))
)
(declare-rare-rule bool-and-de-morgan ((x1 Bool) (y1 Bool) (zs1 Bool :list))
  :args (x1 y1 zs1)
  :conclusion (= (not (and x1 y1 zs1)) (or (not x1) (not (and y1 zs1))))
)
(declare-rare-rule bool-or-and-distrib ((y1 Bool) (y2 Bool) (y3 Bool :list) (zs1 Bool :list))
  :args (y1 y2 y3 zs1)
  :conclusion (= (or (and y1 y2 y3) zs1) (and (or y1 zs1) (or (and y2 y3) zs1)))
)
(declare-rare-rule bool-xor-refl ((x1 Bool))
  :args (x1)
  :conclusion (= (xor x1 x1) false)
)
(declare-rare-rule bool-xor-nrefl ((x1 Bool))
  :args (x1)
  :conclusion (= (xor x1 (not x1)) true)
)
(declare-rare-rule bool-xor-false ((x1 Bool))
  :args (x1)
  :conclusion (= (xor x1 false) x1)
)
(declare-rare-rule bool-xor-true ((x1 Bool))
  :args (x1)
  :conclusion (= (xor x1 true) (not x1))
)
(declare-rare-rule bool-xor-comm ((x1 Bool) (y1 Bool))
  :args (x1 y1)
  :conclusion (= (xor x1 y1) (xor y1 x1))
)
(declare-rare-rule bool-xor-elim ((x1 Bool) (y1 Bool))
  :args (x1 y1)
  :conclusion (= (xor x1 y1) (= (not x1) y1))
)
(declare-rare-rule bool-not-xor-elim ((x1 Bool) (y1 Bool))
  :args (x1 y1)
  :conclusion (= (not (xor x1 y1)) (= x1 y1))
)
(declare-rare-rule bool-not-eq-elim1 ((x1 Bool) (y1 Bool))
  :args (x1 y1)
  :conclusion (= (not (= x1 y1)) (= (not x1) y1))
)
(declare-rare-rule bool-not-eq-elim2 ((x1 Bool) (y1 Bool))
  :args (x1 y1)
  :conclusion (= (not (= x1 y1)) (= x1 (not y1)))
)
(declare-rare-rule ite-neg-branch ((c1 Bool) (x1 Bool) (y1 Bool))
  :premises ((= (not y1) x1))
  :args (c1 x1 y1)
  :conclusion (= (ite c1 x1 y1) (= c1 x1))
)
(declare-rare-rule ite-then-true ((c1 Bool) (x1 Bool))
  :args (c1 x1)
  :conclusion (= (ite c1 true x1) (or c1 x1))
)
(declare-rare-rule ite-else-false ((c1 Bool) (x1 Bool))
  :args (c1 x1)
  :conclusion (= (ite c1 x1 false) (and c1 x1))
)
(declare-rare-rule ite-then-false ((c1 Bool) (x1 Bool))
  :args (c1 x1)
  :conclusion (= (ite c1 false x1) (and (not c1) x1))
)
(declare-rare-rule ite-else-true ((c1 Bool) (x1 Bool))
  :args (c1 x1)
  :conclusion (= (ite c1 x1 true) (or (not c1) x1))
)
(declare-rare-rule ite-then-lookahead-self ((c1 Bool) (x1 Bool))
  :args (c1 x1)
  :conclusion (= (ite c1 c1 x1) (ite c1 true x1))
)
(declare-rare-rule ite-else-lookahead-self ((c1 Bool) (x1 Bool))
  :args (c1 x1)
  :conclusion (= (ite c1 x1 c1) (ite c1 x1 false))
)
(declare-rare-rule ite-then-lookahead-not-self ((c1 Bool) (x1 Bool))
  :args (c1 x1)
  :conclusion (= (ite c1 (not c1) x1) (ite c1 false x1))
)
(declare-rare-rule ite-else-lookahead-not-self ((c1 Bool) (x1 Bool))
  :args (c1 x1)
  :conclusion (= (ite c1 x1 (not c1)) (ite c1 x1 true))
)
(declare-rare-rule ite-expand ((c1 Bool) (x1 Bool) (y1 Bool))
  :args (c1 x1 y1)
  :conclusion (= (ite c1 x1 y1) (and (or (not c1) x1) (or c1 y1)))
)
(declare-rare-rule bool-not-ite-elim ((c1 Bool) (x1 Bool) (y1 Bool))
  :args (c1 x1 y1)
  :conclusion (= (not (ite c1 x1 y1)) (ite c1 (not x1) (not y1)))
)
(declare-rare-rule ite-true-cond ((@T0 Type) (@T1 Type) (x1 @T0) (y1 @T1))
  :args (x1 y1)
  :conclusion (= (ite true x1 y1) x1)
)
(declare-rare-rule ite-false-cond ((@T0 Type) (@T1 Type) (x1 @T0) (y1 @T1))
  :args (x1 y1)
  :conclusion (= (ite false x1 y1) y1)
)
(declare-rare-rule ite-not-cond ((@T0 Type) (@T1 Type) (c1 Bool) (x1 @T0) (y1 @T1))
  :args (c1 x1 y1)
  :conclusion (= (ite (not c1) x1 y1) (ite c1 y1 x1))
)
(declare-rare-rule ite-eq-branch ((@T0 Type) (c1 Bool) (x1 @T0))
  :args (c1 x1)
  :conclusion (= (ite c1 x1 x1) x1)
)
(declare-rare-rule ite-then-lookahead ((@T0 Type) (@T1 Type) (@T2 Type) (c1 Bool) (x1 @T0) (y1 @T1) (z1 @T2))
  :args (c1 x1 y1 z1)
  :conclusion (= (ite c1 (ite c1 x1 y1) z1) (ite c1 x1 z1))
)
(declare-rare-rule ite-else-lookahead ((@T0 Type) (@T1 Type) (@T2 Type) (c1 Bool) (x1 @T0) (y1 @T1) (z1 @T2))
  :args (c1 x1 y1 z1)
  :conclusion (= (ite c1 x1 (ite c1 y1 z1)) (ite c1 x1 z1))
)
(declare-rare-rule ite-then-neg-lookahead ((@T0 Type) (@T1 Type) (@T2 Type) (c1 Bool) (x1 @T0) (y1 @T1) (z1 @T2))
  :args (c1 x1 y1 z1)
  :conclusion (= (ite c1 (ite (not c1) x1 y1) z1) (ite c1 y1 z1))
)
(declare-rare-rule ite-else-neg-lookahead ((@T0 Type) (@T1 Type) (@T2 Type) (c1 Bool) (x1 @T0) (y1 @T1) (z1 @T2))
  :args (c1 x1 y1 z1)
  :conclusion (= (ite c1 x1 (ite (not c1) y1 z1)) (ite c1 x1 y1))
)
(declare-rare-rule eq-refl ((@T0 Type) (t1 @T0))
  :args (t1)
  :conclusion (= (= t1 t1) true)
)
(declare-rare-rule eq-symm ((@T0 Type) (@T1 Type) (t1 @T0) (s1 @T1))
  :args (t1 s1)
  :conclusion (= (= t1 s1) (= s1 t1))
)
(declare-rare-rule eq-cond-deq ((@T0 Type) (@T1 Type) (@T2 Type) (t1 @T0) (s1 @T1) (r1 @T2))
  :premises ((= (= s1 r1) false))
  :args (t1 s1 r1)
  :conclusion (= (= (= t1 s1) (= t1 r1)) (and (not (= t1 s1)) (not (= t1 r1))))
)
(declare-rare-rule eq-ite-lift ((@T0 Type) (@T1 Type) (@T2 Type) (C1 Bool) (t1 @T0) (s1 @T1) (r1 @T2))
  :args (C1 t1 s1 r1)
  :conclusion (= (= (ite C1 t1 s1) r1) (ite C1 (= t1 r1) (= s1 r1)))
)
(declare-rare-rule distinct-binary-elim ((@T0 Type) (@T1 Type) (t1 @T0) (s1 @T1))
  :args (t1 s1)
  :conclusion (= (distinct t1 s1) (not (= t1 s1)))
)
(declare-rare-rule uf-bv2nat-int2bv ((@n0 Int) (w1 Int) (t1 (BitVec @n0)))
  :premises ((= (@bvsize t1) w1))
  :args (w1 t1)
  :conclusion (= (int2bv w1 (bv2nat t1)) t1)
)
(declare-rare-rule uf-bv2nat-int2bv-extend ((@n0 Int) (w1 Int) (t1 (BitVec @n0)) (n1 Int))
  :premises ((= (> w1 (@bvsize t1)) true) (= n1 (- w1 (@bvsize t1))))
  :args (w1 t1 n1)
  :conclusion (= (int2bv w1 (bv2nat t1)) (concat (@bv 0 n1) t1))
)
(declare-rare-rule uf-bv2nat-int2bv-extract ((@n0 Int) (w1 Int) (t1 (BitVec @n0)) (wm1 Int))
  :premises ((= (< w1 (@bvsize t1)) true) (= wm1 (- w1 1)))
  :args (w1 t1 wm1)
  :conclusion (= (int2bv w1 (bv2nat t1)) (extract wm1 0 t1))
)
(declare-rare-rule uf-int2bv-bv2nat ((w1 Int) (t1 Int))
  :args (w1 t1)
  :conclusion (= (bv2nat (int2bv w1 t1)) (mod_total t1 (int.pow2 w1)))
)
(declare-rare-rule uf-bv2nat-geq-elim ((@n0 Int) (x1 (BitVec @n0)) (n1 Int) (w1 Int))
  :premises ((= w1 (@bvsize x1)))
  :args (x1 n1 w1)
  :conclusion (= (>= (bv2nat x1) n1) (ite (>= n1 w1) false (ite (< n1 0) true (bvuge x1 (int2bv w1 n1)))))
)
(declare-rare-rule uf-int2bv-bvult-equiv ((@n0 Int) (@n1 Int) (t1 (BitVec @n0)) (s1 (BitVec @n1)))
  :args (t1 s1)
  :conclusion (= (bvult t1 s1) (< (bv2nat t1) (bv2nat s1)))
)
(declare-rare-rule uf-int2bv-bvule-equiv ((@n0 Int) (@n1 Int) (t1 (BitVec @n0)) (s1 (BitVec @n1)))
  :args (t1 s1)
  :conclusion (= (bvule t1 s1) (<= (bv2nat t1) (bv2nat s1)))
)