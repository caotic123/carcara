unsat
(assume slice_assume_false false)
(anchor :step t28)
(assume t28.a0 (>= (+ (* -1/1 (divide$ (of_nat$ n$) 6.0)) (ln$ (fact$ n$)) (* -2/1 (ln$ (fact$ (divide$a n$ (numeral$ (bit0$ one$)))))) (* -1/1 (psi$ (divide$a n$ (numeral$ (bit1$ one$)))))) 0.0))
(assume t28.a1 (not (>= (+ (* -1/1 (divide$ (of_nat$ n$) 6.0)) (psi$ n$) (* -1/1 (psi$ (divide$a n$ (numeral$ (bit0$ one$)))))) 0.0)))
(assume t28.a2 (>= (+ (psi$ n$) (* -1/1 (psi$ (divide$a n$ (numeral$ (bit0$ one$))))) (* -1/1 (ln$ (fact$ n$))) (* 2.0 (ln$ (fact$ (divide$a n$ (numeral$ (bit0$ one$)))))) (psi$ (divide$a n$ (numeral$ (bit1$ one$))))) 0.0))
(anchor :step t28.t37)
(assume t28.t37.a0 (>= (+ (psi$ n$) (* -1/1 (psi$ (divide$a n$ (numeral$ (bit0$ one$))))) (* -1/1 (ln$ (fact$ n$))) (* 2.0 (ln$ (fact$ (divide$a n$ (numeral$ (bit0$ one$)))))) (psi$ (divide$a n$ (numeral$ (bit1$ one$))))) 0.0))
(step st28.t37.t49 
   (cl (= (> (+ (divide$ (of_nat$ n$) 6.0) (* -1/1 (psi$ n$)) (psi$ (divide$a n$ (numeral$ (bit0$ one$))))) 0.0) (not (<= (+ (divide$ (of_nat$ n$) 6.0) (* -1/1 (psi$ n$)) (psi$ (divide$a n$ (numeral$ (bit0$ one$))))) 0.0)))) :rule 
   rare_rewrite :args ("arith-elim-gt" (+ (divide$ (of_nat$ n$) 6.0) (* -1/1 (psi$ n$)) (psi$ (divide$a n$ (numeral$ (bit0$ one$))))) 0.0))
(step t28.t37.t118 (cl false) :rule trust)
(step t28.t37 (cl (not (>= (+ (psi$ n$) (* -1/1 (psi$ (divide$a n$ (numeral$ (bit0$ one$))))) (* -1/1 (ln$ (fact$ n$))) (* 2.0 (ln$ (fact$ (divide$a n$ (numeral$ (bit0$ one$)))))) (psi$ (divide$a n$ (numeral$ (bit1$ one$))))) 0.0)) false) :rule subproof :discharge (t28.t37.a0))
(step t28.t47 (cl) :rule trust)
(step t28 (cl (not (>= (+ (* -1/1 (divide$ (of_nat$ n$) 6.0)) (ln$ (fact$ n$)) (* -2/1 (ln$ (fact$ (divide$a n$ (numeral$ (bit0$ one$)))))) (* -1/1 (psi$ (divide$a n$ (numeral$ (bit1$ one$)))))) 0.0)) (not (not (>= (+ (* -1/1 (divide$ (of_nat$ n$) 6.0)) (psi$ n$) (* -1/1 (psi$ (divide$a n$ (numeral$ (bit0$ one$)))))) 0.0))) (not (>= (+ (psi$ n$) (* -1/1 (psi$ (divide$a n$ (numeral$ (bit0$ one$))))) (* -1/1 (ln$ (fact$ n$))) (* 2.0 (ln$ (fact$ (divide$a n$ (numeral$ (bit0$ one$)))))) (psi$ (divide$a n$ (numeral$ (bit1$ one$))))) 0.0)) false) :rule subproof :discharge (t28.a0 t28.a1 t28.a2))
(step slice_not_false (cl (not false)) :rule false)
(step t.end (cl) :rule resolution :premises (slice_assume_false slice_not_false))
