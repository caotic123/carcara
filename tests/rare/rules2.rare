
(declare-const eo::typeof (-> (! Type :var A :implicit) A Type))
(declare-const eo::nil (-> (! Type :var A :implicit) (! Type :var B :implicit) A Type B))
(declare-const BitVec (-> Int Type))
(declare-parameterized-const eo::to_bin ((m Int)) (-> Int (BitVec m)))

(declare-const ite (-> (! Type :var A :implicit) Bool A A A))
(declare-const not (-> Bool Bool))
(declare-const or (-> Bool Bool Bool) :right-assoc-nil false)
(declare-const and (-> Bool Bool Bool) :right-assoc-nil true)
(declare-const => (-> Bool Bool Bool) :right-assoc)
(declare-const xor (-> Bool Bool Bool) :left-assoc)

(declare-const distinct (-> (! Type :var A :implicit) A A Bool) :pairwise and)

(declare-parameterized-const bvor ((n Int :implicit))
    (-> (BitVec n) (BitVec n) (BitVec n))
    :right-assoc-nil (eo::to_bin n 0)               
)

(program eo::eq ((T Type) (x T) (y T))
  :signature (T T) Bool
  (
    ((eo::eq x x) true)
    ((eo::eq x y) false)
  )
)

(program eo::ite ((T Type) (c Bool) (x T) (y T))
  :signature (Bool T T) T
  (
    ((eo::ite true x y) x)
    ((eo::ite false x y) y)
  )
)

(program contains
    ((f (-> Bool Bool Bool)) (l Bool) (x Bool) (xs Bool))
    :signature ((-> Bool Bool Bool) Bool Bool) Bool
    (
        ((contains f false l)     false)
        ((contains f (f l xs) l) true)
        ((contains f (f x xs) l) (contains f xs l))
    )
)

; program: $singleton_elim
; args:
; - s S: The term to proces.
; return: >
;   The result of applying singleton elimination for s. In particular,
;   if s is of the form (f x1 x2) where x2 is the nil terminator of f, then we
;   return x1. Otherwise, we return s unchanged.
(program $singleton_elim ((f (-> Bool Bool Bool)) (x Bool) (x1 Bool) (x2 Bool))
  :signature (Bool) Bool
  (
    (($singleton_elim (f x1 x2))  (eo::ite (eo::eq x2 (eo::nil f (eo::typeof (f x1 x2)))) x1 (f x1 x2)))
    (($singleton_elim x)          x)
  )
)

(declare-rare-rule true_elimination ((x Bool) (y Bool :list)) 
  :args (x y)
  :conclusion (= (and x y) ($singleton_elim (and x y)))
)

(declare-rare-rule or_elim ((x Bool) (y Bool :list)) 
  :args (x y)
  :premises ((= (contains or (or x y) true) true))
  :conclusion (= (or x y) true)
)

(declare-rare-rule type_rule ((x Bool)) 
  :args (x)
  :conclusion (= (eo::typeof x) (eo::typeof x))
)