(assume a0 (and (<= skoT 0/1) (and (not (= skoT 0/1)) (and (not (<= skoB (* skoA (- 1/1)))) (and (not (<= skoT 1/1)) (not (<= skoB skoA)))))))
(step t0 (cl (not (= (< (+ skoT (* -1/1 skoT)) (+ 0/1 (* -1/1 1/1))) false)) (not (< (+ skoT (* -1/1 skoT)) (+ 0/1 (* -1/1 1/1)))) false) :rule equiv_pos2)
(step t1 (cl (= (< (+ skoT (* -1/1 skoT)) (+ 0/1 (* -1/1 1/1))) (not (>= (+ skoT (* -1/1 skoT)) (+ 0/1 (* -1/1 1/1)))))) :rule hole :args ("TRUST_THEORY_REWRITE" (= (< (+ skoT (* -1/1 skoT)) (+ 0/1 (* -1/1 1/1))) (not (>= (+ skoT (* -1/1 skoT)) (+ 0/1 (* -1/1 1/1))))) 3 6))
(step t2 (cl (= skoT skoT)) :rule refl)
(step t3 (cl (= (* -1/1 skoT) (* -1 skoT))) :rule hole :args ("TRUST_THEORY_REWRITE" (= (* -1/1 skoT) (* -1 skoT)) 3 7))
(step t4 (cl (= (+ skoT (* -1/1 skoT)) (+ skoT (* -1 skoT)))) :rule cong :premises (t2 t3))
(step t5 (cl (= (+ skoT (* -1 skoT)) 0/1)) :rule hole :args ("TRUST_THEORY_REWRITE" (= (+ skoT (* -1 skoT)) 0/1) 3 7))
(step t6 (cl (= (+ skoT (* -1/1 skoT)) 0/1)) :rule trans :premises (t4 t5))
(step t7 (cl (= 0/1 0/1)) :rule refl)
(step t8 (cl (= (* -1/1 1/1) -1/1)) :rule hole :args ("TRUST_THEORY_REWRITE" (= (* -1/1 1/1) -1/1) 3 7))
(step t9 (cl (= (+ 0/1 (* -1/1 1/1)) (+ 0/1 -1/1))) :rule cong :premises (t7 t8))
(step t10 (cl (= (+ 0/1 -1/1) -1/1)) :rule hole :args ("TRUST_THEORY_REWRITE" (= (+ 0/1 -1/1) -1/1) 3 7))
(step t11 (cl (= (+ 0/1 (* -1/1 1/1)) -1/1)) :rule trans :premises (t9 t10))
(step t12 (cl (= (>= (+ skoT (* -1/1 skoT)) (+ 0/1 (* -1/1 1/1))) (>= 0/1 -1/1))) :rule cong :premises (t6 t11))
(step t13 (cl (= (>= 0/1 -1/1) true)) :rule hole :args ("TRUST_THEORY_REWRITE" (= (>= 0/1 -1/1) true) 3 7))
(step t14 (cl (= (>= (+ skoT (* -1/1 skoT)) (+ 0/1 (* -1/1 1/1))) true)) :rule trans :premises (t12 t13))
(step t15 (cl (= (not (>= (+ skoT (* -1/1 skoT)) (+ 0/1 (* -1/1 1/1)))) (not true))) :rule cong :premises (t14))
(step t16 (cl (= (not true) false)) :rule hole :args ("TRUST_THEORY_REWRITE" (= (not true) false) 1 7))
(step t17 (cl (= (not (>= (+ skoT (* -1/1 skoT)) (+ 0/1 (* -1/1 1/1)))) false)) :rule trans :premises (t15 t16))
(step t18 (cl (= (< (+ skoT (* -1/1 skoT)) (+ 0/1 (* -1/1 1/1))) false)) :rule trans :premises (t1 t17))
(step t19 (cl (not (<= skoT 0/1)) (not (< (* -1/1 skoT) (* -1/1 1/1))) (< (+ skoT (* -1/1 skoT)) (+ 0/1 (* -1/1 1/1)))) :rule la_generic :args (1/1 1/1 1/1))
(step t20 (cl (<= skoT 0/1)) :rule and :premises (a0) :args (0))
(step t21 (cl (=> (and (< -1/1 0/1) (> skoT 1/1)) (< (* -1/1 skoT) (* -1/1 1/1)))) :rule la_mult_neg)
(step t22 (cl (not (and (< -1/1 0/1) (> skoT 1/1))) (< (* -1/1 skoT) (* -1/1 1/1))) :rule implies :premises (t21))
(step t23 (cl (and (< -1/1 0/1) (> skoT 1/1)) (not (< -1/1 0/1)) (not (> skoT 1/1))) :rule and_neg)
(step t24 (cl (= (= (< -1/1 0/1) true) (< -1/1 0/1))) :rule equiv_simplify)
(step t25 (cl (not (= (< -1/1 0/1) true)) (< -1/1 0/1)) :rule equiv1 :premises (t24))
(step t26 (cl (= (< -1/1 0/1) true)) :rule hole)
(step t27 (cl (< -1/1 0/1)) :rule resolution :premises (t25 t26))
(step t28 (cl (not (= (not (>= (* -1 skoT) -1)) (> skoT 1/1))) (not (not (>= (* -1 skoT) -1))) (> skoT 1/1)) :rule equiv_pos2)
(step t29 (cl (= (> skoT 1/1) (not (<= skoT 1/1)))) :rule hole :args ("TRUST_THEORY_REWRITE" (= (> skoT 1/1) (not (<= skoT 1/1))) 3 6))
(step t30 (cl (= (<= skoT 1/1) (>= (* -1 skoT) -1))) :rule hole :args ("TRUST_THEORY_REWRITE" (= (<= skoT 1/1) (>= (* -1 skoT) -1)) 3 7))
(step t31 (cl (= (not (<= skoT 1/1)) (not (>= (* -1 skoT) -1)))) :rule cong :premises (t30))
(step t32 (cl (= (> skoT 1/1) (not (>= (* -1 skoT) -1)))) :rule trans :premises (t29 t31))
(step t33 (cl (= (not (>= (* -1 skoT) -1)) (> skoT 1/1))) :rule symm :premises (t32))
(step t34 (cl (not (= (not (<= skoT 1/1)) (not (>= (* -1 skoT) -1)))) (not (not (<= skoT 1/1))) (not (>= (* -1 skoT) -1))) :rule equiv_pos2)
(step t35 (cl (and (not (= skoT 0/1)) (and (not (<= skoB (* skoA (- 1/1)))) (and (not (<= skoT 1/1)) (not (<= skoB skoA)))))) :rule and :premises (a0) :args (1))
(step t36 (cl (and (not (<= skoB (* skoA (- 1/1)))) (and (not (<= skoT 1/1)) (not (<= skoB skoA))))) :rule and :premises (t35) :args (1))
(step t37 (cl (and (not (<= skoT 1/1)) (not (<= skoB skoA)))) :rule and :premises (t36) :args (1))
(step t38 (cl (not (<= skoT 1/1))) :rule and :premises (t37) :args (0))
(step t39 (cl (not (>= (* -1 skoT) -1))) :rule resolution :premises (t34 t31 t38))
(step t40 (cl (> skoT 1/1)) :rule resolution :premises (t28 t33 t39))
(step t41 (cl (and (< -1/1 0/1) (> skoT 1/1))) :rule resolution :premises (t23 t27 t40))
(step t42 (cl (< (* -1/1 skoT) (* -1/1 1/1))) :rule resolution :premises (t22 t41))
(step t43 (cl (< (+ skoT (* -1/1 skoT)) (+ 0/1 (* -1/1 1/1)))) :rule resolution :premises (t19 t20 t42))
(step t44 (cl false) :rule resolution :premises (t0 t18 t43))
(step t45 (cl (not false)) :rule false)
(step t46 (cl) :rule resolution :premises (t44 t45))
