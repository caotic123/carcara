(assume a0 (and (<= skoT 0/1) (and (not (= skoT 0/1)) (and (not (<= skoB (* skoA (- 1/1)))) (and (not (<= skoT 1/1)) (not (<= skoB skoA)))))))
(step t0 (cl (not (= (< (+ skoT (* -1/1 skoT)) (+ 0/1 (* -1/1 1/1))) false)) (not (< (+ skoT (* -1/1 skoT)) (+ 0/1 (* -1/1 1/1)))) false) :rule equiv_pos2)
(step t1 (cl (= (< (+ skoT (* -1/1 skoT)) (+ 0/1 (* -1/1 1/1))) (not (>= (+ skoT (* -1/1 skoT)) (+ 0/1 (* -1/1 1/1)))))) :rule rare_rewrite :args ("arith-elim-lt" (+ skoT (* -1/1 skoT)) (+ 0/1 (* -1/1 1/1))))
(step t2 (cl (= skoT skoT)) :rule refl)
(step t3 (cl (= (* -1/1 skoT) (* -1 skoT))) :rule rare_rewrite :args ("arith-poly-norm"))
(step t4 (cl (= (+ skoT (* -1/1 skoT)) (+ skoT (* -1 skoT)))) :rule cong :premises (t2 t3))
(step t5 (cl (= (+ skoT (* -1 skoT)) 0/1)) :rule rare_rewrite :args ("arith-poly-norm"))
(step t6 (cl (= (+ skoT (* -1/1 skoT)) 0/1)) :rule trans :premises (t4 t5))
(step t7 (cl (= 0/1 0/1)) :rule refl)
(step t8 (cl (= (* -1/1 1/1) -1/1)) :rule rare_rewrite :args ("evaluate"))
(step t9 (cl (= (+ 0/1 (* -1/1 1/1)) (+ 0/1 -1/1))) :rule cong :premises (t7 t8))
(step t10 (cl (= (+ 0/1 -1/1) -1/1)) :rule rare_rewrite :args ("evaluate"))
(step t11 (cl (= (+ 0/1 (* -1/1 1/1)) -1/1)) :rule trans :premises (t9 t10))
(step t12 (cl (= (>= (+ skoT (* -1/1 skoT)) (+ 0/1 (* -1/1 1/1))) (>= 0/1 -1/1))) :rule cong :premises (t6 t11))
(step t13 (cl (= (>= 0/1 -1/1) true)) :rule rare_rewrite :args ("evaluate"))
(step t14 (cl (= (>= (+ skoT (* -1/1 skoT)) (+ 0/1 (* -1/1 1/1))) true)) :rule trans :premises (t12 t13))
(step t15 (cl (= (not (>= (+ skoT (* -1/1 skoT)) (+ 0/1 (* -1/1 1/1)))) (not true))) :rule cong :premises (t14))
(step t16 (cl (= (not true) false)) :rule rare_rewrite :args ("evaluate"))
(step t17 (cl (= (not (>= (+ skoT (* -1/1 skoT)) (+ 0/1 (* -1/1 1/1)))) false)) :rule trans :premises (t15 t16))
(step t18 (cl (= (< (+ skoT (* -1/1 skoT)) (+ 0/1 (* -1/1 1/1))) false)) :rule trans :premises (t1 t17))
(step t19 (cl (not (<= skoT 0/1)) (not (< (* -1/1 skoT) (* -1/1 1/1))) (< (+ skoT (* -1/1 skoT)) (+ 0/1 (* -1/1 1/1)))) :rule la_generic :args (1/1 1/1 1/1))
(step t20 (cl (<= skoT 0/1)) :rule and :premises (a0) :args (0))
(step t21 (cl (=> (and (< -1/1 0/1) (> skoT 1/1)) (< (* -1/1 skoT) (* -1/1 1/1)))) :rule la_mult_neg)
(step t22 (cl (not (and (< -1/1 0/1) (> skoT 1/1))) (< (* -1/1 skoT) (* -1/1 1/1))) :rule implies :premises (t21))
(step t23 (cl (and (< -1/1 0/1) (> skoT 1/1)) (not (< -1/1 0/1)) (not (> skoT 1/1))) :rule and_neg)
(step t24 (cl (= (= (< -1/1 0/1) true) (< -1/1 0/1))) :rule equiv_simplify)
(step t25 (cl (not (= (< -1/1 0/1) true)) (< -1/1 0/1)) :rule equiv1 :premises (t24))
(step t26 (cl (= (< -1/1 0/1) true)) :rule rare_rewrite :args ("evaluate"))
(step t27 (cl (< -1/1 0/1)) :rule resolution :premises (t25 t26))
(step t28 (cl (not (= (not (>= (* -1 skoT) -1)) (> skoT 1/1))) (not (not (>= (* -1 skoT) -1))) (> skoT 1/1)) :rule equiv_pos2)
(step t29 (cl (= (> skoT 1/1) (not (>= 1/1 skoT)))) :rule rare_rewrite :args ("arith-elim-gt" skoT 1/1))
(step t30 (cl (= (<= skoT 1/1) (>= 1/1 skoT))) :rule rare_rewrite :args ("arith-elim-leq" skoT 1/1))
(step t31 (cl (= (>= 1/1 skoT) (<= skoT 1/1))) :rule symm :premises (t30))
(step t32 (cl (= (not (>= 1/1 skoT)) (not (<= skoT 1/1)))) :rule cong :premises (t31))
(step t33 (cl (= (> skoT 1/1) (not (<= skoT 1/1)))) :rule trans :premises (t29 t32))
(step t34 (cl (= (* 1/1 (- 1/1 skoT)) (* 1/1 (- (* -1 skoT) -1)))) :rule rare_rewrite :args ("arith-poly-norm"))
(step t35 (cl (= (>= 1/1 skoT) (>= (* -1 skoT) -1))) :rule hole :premises (t34) :args ("ARITH_POLY_NORM_REL" (= (>= 1/1 skoT) (>= (* -1 skoT) -1))))
(step t36 (cl (= (<= skoT 1/1) (>= (* -1 skoT) -1))) :rule trans :premises (t30 t35))
(step t37 (cl (= (not (<= skoT 1/1)) (not (>= (* -1 skoT) -1)))) :rule cong :premises (t36))
(step t38 (cl (= (> skoT 1/1) (not (>= (* -1 skoT) -1)))) :rule trans :premises (t33 t37))
(step t39 (cl (= (not (>= (* -1 skoT) -1)) (> skoT 1/1))) :rule symm :premises (t38))
(step t40 (cl (not (= (not (<= skoT 1/1)) (not (>= (* -1 skoT) -1)))) (not (not (<= skoT 1/1))) (not (>= (* -1 skoT) -1))) :rule equiv_pos2)
(step t41 (cl (and (not (= skoT 0/1)) (and (not (<= skoB (* skoA (- 1/1)))) (and (not (<= skoT 1/1)) (not (<= skoB skoA)))))) :rule and :premises (a0) :args (1))
(step t42 (cl (and (not (<= skoB (* skoA (- 1/1)))) (and (not (<= skoT 1/1)) (not (<= skoB skoA))))) :rule and :premises (t41) :args (1))
(step t43 (cl (and (not (<= skoT 1/1)) (not (<= skoB skoA)))) :rule and :premises (t42) :args (1))
(step t44 (cl (not (<= skoT 1/1))) :rule and :premises (t43) :args (0))
(step t45 (cl (not (>= (* -1 skoT) -1))) :rule resolution :premises (t40 t37 t44))
(step t46 (cl (> skoT 1/1)) :rule resolution :premises (t28 t39 t45))
(step t47 (cl (and (< -1/1 0/1) (> skoT 1/1))) :rule resolution :premises (t23 t27 t46))
(step t48 (cl (< (* -1/1 skoT) (* -1/1 1/1))) :rule resolution :premises (t22 t47))
(step t49 (cl (< (+ skoT (* -1/1 skoT)) (+ 0/1 (* -1/1 1/1)))) :rule resolution :premises (t19 t20 t48))
(step t50 (cl false) :rule resolution :premises (t0 t18 t49))
(step t51 (cl (not false)) :rule false)
(step t52 (cl) :rule resolution :premises (t50 t51))
