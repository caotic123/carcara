
(assume a0 (and (> x 1) (> y 1)))
(assume a1 (! (distinct (! (* (* 2 x) y) :named @p_2) (! (* x (* 2 y)) :named @p_1)) :named @p_3))
(step t0 (cl (not (! (= @p_3 false) :named @p_4)) (not @p_3) false) :rule equiv_pos2)
(step t1 (cl (= @p_3 (! (not (! (= @p_2 @p_1) :named @p_5)) :named @p_6))) :rule hole :args ("TRUST_THEORY_REWRITE" (= @p_3 @p_6) 0 6))
(step t2 (cl (= @p_2 (! (* 2 (* x y)) :named @p_7))) :rule hole :args ("TRUST_THEORY_REWRITE" (= @p_2 @p_7) 3 7))
(step t3 (cl (= @p_1 @p_7)) :rule hole :args ("TRUST_THEORY_REWRITE" (= @p_1 @p_7) 3 7))
(step t4 (cl (= @p_5 (= @p_7 @p_7))) :rule cong :premises (t2 t3))
(step t5 (cl (= (= @p_7 @p_7) true)) :rule hole :args ("TRUST_THEORY_REWRITE" (= (= @p_7 @p_7) true) 3 7))
(step t6 (cl (= @p_5 true)) :rule trans :premises (t4 t5))
(step t7 (cl (= @p_6 (not true))) :rule cong :premises (t6))
(step t8 (cl (= (not true) false)) :rule hole :args ("TRUST_THEORY_REWRITE" (= (not true) false) 1 7))
(step t9 (cl (= @p_6 false)) :rule trans :premises (t7 t8))
(step t10 (cl @p_4) :rule trans :premises (t1 t9))
(step t11 (cl false) :rule resolution :premises (t0 t10 a1) :args (@p_4 false @p_3 false))
(step t12 (cl (not false)) :rule false)
(step t13 (cl) :rule resolution :premises (t11 t12) :args (false true))
